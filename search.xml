<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[常用设计模式]]></title>
    <url>%2F2018%2F08%2F26%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[[^_^]: &gt; 常用设计模式Singleton（单例模式）一句话总结：一个类在Java虚拟机中只有一个对象，并提供一个全局访问点。 生活中例子：太阳、月亮、国家主席等。 解决什么问题：对象的唯一性，性能浪费太多。 项目里面怎么用：数据库连接对象，属性配置文件的读取对象。 模式结构：分为饿汉式和懒汉式（如果考虑性能问题的话，就使用懒汉式，因为懒汉式是在方法里面进行初始化的），构造器私 有化，对外提供方法加同步关键字。 框架里面使用：Struts1的Action。 JDK里面使用：java.lang.Runtime#getRuntimejava.awt.Desktop#getDesktop。饿汉式代码：1234567public class HurgrySingleton &#123; private static HurgrySingleton hurgry=new HurgrySingleton(); private HurgrySingleton()&#123;&#125;; public static HurgrySingleton getSinletonHurgry()&#123; return hurgry; &#125; &#125; 懒汉式代码：12345678910public class LarzySingleton &#123; private static LarzySingleton larzy=null; private LarzySingleton()&#123;&#125;; public static synchronized Larzy getSinletonLarzy()&#123; if(larzy==null)&#123; larzy=new LarzySingleton(); &#125; return larzy; &#125; &#125; Factory（简单的工厂模式）一句话总结：用一个方法来代替new关键字 生活中的例子：制衣厂、面包厂等生产厂。 解决什么问题：对象产生过多，或者经常有子类替换生成。 项目里面怎么用：对于经常生成的对象，或者父子类替换的对象。 模式结构：写一个对外声明的方法，方法里面使用new关键字代替。 框架里面使用：spring的核心就是工厂模式。 JDK里面使用：newInstance。 工厂模式代码：123456789public class UserFactory &#123; public static User createUser(int i)&#123; //如果输入的是1，就创建它的子类，否则就创建父类 if(i==1)&#123; return new Alices(); &#125; return new User(); &#125; &#125; Proxy（代理模式）一句话总结：为其他对象提供一个代理，以控制对当前对象的访问。 生活中的例子：房屋中介、婚姻介绍所。 解决什么问题：不能直接访问该对象，或者太大的资源耗费多。 项目里面怎么用：权限，或者大对象的访问权限。 模式结构：代理类和被代理类实现同一个接口，用户访问的时候先访问代理对象，然后让代理对象去访问被代理对象。 框架里面使用：Spring里面的AOP实现。 JDK里面使用：java.lang.reflect.Proxy。 代理模式代码：创建一个接口：123public interface SellHouse &#123; void sell(double money); &#125; 创建一个被代理类：123456public class Hoster implements SellHouse &#123; @Override public void sell(double money) &#123; System.out.println("祝你居住愉快"); &#125; &#125; 创建一个代理类：1234567891011public class Medium implements SellHouse &#123; SellHouse hoster=new Hoster(); @Override public void sell(double money) &#123; if(money&gt;=1000)&#123; hoster.sell(money); &#125;else&#123; System.out.println("你的价格太低了"); &#125; &#125; &#125; 测试类：123456public class Renter &#123; public static void main(String[] args) &#123; SellHouse renter=new Medium(); renter.sell(500); &#125; &#125; Adapter（适配器模式）一句话总结：将两个原来不兼容的类兼容起来一起工作。 生活中的例子：变压器、充电器 解决什么问题：已经存在的相同功能的代码，但是接口不兼容，不能直接调用。 项目里面怎么用：在使用旧的API的时候，没有源码，和新的不能兼容。 模式结构：分为类适配器和对象适配，一般常用的就是对象适配器，因为组合由于继承。 框架里面使用：单元测试里面的asserEquels。 JDK里面使用：java.util.Arrays#asListjava.io.InputStreamReader(InputStream) java.io.outputStreamWriter(OutputStream)。 Strategy（策略模式）一句话总结：定义一系列算法并可以互相替换。 生活中的例子：图片的格式，压缩文件的格式。 解决什么问题：做一件事情有很多种方法。 项目里面怎么用：购物车里面的付款方式。 模式结构：声明一个顶级接口，定义一个策略方法，具体的实例都要实现这个接口。 框架里面使用：hibernate的主键生成策略。 JDK里面使用：java.util.Comparator#compare。 策略模式代码：定义一个顶级接口： 123public interface Person &#123; void repast(); &#125; 具体的实例类1：123456public class African implements Person &#123; @Override public void repast() &#123; System.out.println("非洲人用手吃饭"); &#125; &#125; 具体的实例类2：123456public class America implements Person &#123; @Override public void repast() &#123; System.out.println("美国人用刀叉吃饭"); &#125; &#125; 具体的实例类3： 123456public class Chinese implements Person &#123; @Override public void repast() &#123; System.out.println("中国人用筷子吃饭"); &#125; &#125; 测试类： 12345678910public class Test &#123; public static void main(String[] args) &#123; Person chinese=new Chinese(); Person america=new America(); Person african=new African(); chinese.repast(); america.repast(); african.repast(); &#125; &#125; Template（模板模式）一句话总结：父类定义流程，子类实现流程。 生活中的例子：iphone生产有多个国家，但流程只有一个。 解决什么问题：业务有多种，但都有规定的流程。 项目里面怎么用：一般基类的实现都是模板模式，BaseDAO，bBaseService。 模式结构：定义一个抽象父类定义流程，或者常用方法和常量，子类继承父类，实现具体的细节方法。 框架里面使用：hibernate里面的方言，是跨数据库的基础。 JDK里面使用：IO流里面的InputStream，Writer等。 模板模式代码： //定义一个父类，定义流程 123456789101112public abstract class IPhoneTemplate &#123; public void createIPhone()&#123; setupCpu(); setupAll(); check(); box(); &#125; protected abstract void box(); protected abstract boolean check(); protected abstract void setupAll(); protected abstract void setupCpu(); &#125; //子类实现父类的细节方法1 12345678910111213141516171819public class ChinaIPhone extends IPhoneTemplate &#123; @Override protected void box() &#123; System.out.println("box()"); &#125; @Override protected boolean check() &#123; System.out.println("check()"); return true; &#125; @Override protected void setupAll() &#123; System.out.println("setupAll()"); &#125; @Override protected void setupCpu() &#123; System.out.println("setupCpu()"); &#125; &#125; //子类实现父类的细节方法2 12345678910111213141516171819public class AfricanIPhone extends IPhoneTemplate &#123; @Override protected void box() &#123; System.out.println("box()"); &#125; @Override protected boolean check() &#123; System.out.println("check()"); return true; &#125; @Override protected void setupAll() &#123; System.out.println("setupAll()"); &#125; @Override protected void setupCpu() &#123; System.out.println("setupCpu()"); &#125; &#125; [^_^]: 参考阅读 常用设计模式（面试）]]></content>
      <categories>
        <category>面试</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[python基础知识]]></title>
    <url>%2F2018%2F08%2F26%2Fpython%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[[^_^]: &gt; python基础知识可变与不可变类型python中的对象分为：可变对象和不可变对象可变对象：列表（list）、字典（dict ）不可变对象：int、string、float、tuple对不可变类型的变量重新赋值，实际上是重新创建一个不可变类型的对象，并将原来的变量重新指向新创建的对象（如果没有其他变量引用原有对象的话（即引用计数为0），原有对象就会被回收）。 可变与不可变类型作用python函数的参数传递：在python中规定函数的参数传递为引用传递，也就是说传递给函数的参数是这个变量所指向的内存地址。但是在C中，参数传递可以有值传递和引用传递，当需要修改外面参数的值的时候就才用引用传递（在参数前面加一个*，表示传递参数所指的内存地址），但不需要修改外部参数值的时候就采用值传递。 那么在python中如何实现和值传递和引用传递相似的功能呢？———可变类型和不可变类型就发挥作用了。当你需要实现函数参数引用传递的功能的时候，你就将类型为list ,dict的变量传递给相应的函数。当你需要实现函数值传递功能的时候，你就可以将类型为int，float，string，tuple类型的变量传递给函数当做参数。 听说python只允许引用传递是为方便内存管理，因为python使用的内存回收机制是计数器回收，就是每块内存上有一个计数器，表示当前有多少个对象指向该内存。每当一个变量不再使用时，就让该计数器-1，有新对象指向该内存时就让计数器+1，当计时器为0时，就可以收回这块内存了。当然我觉得它肯定不止用了计数器吧，应该还有其他的技术，比如分代回收什么的。不再讨论之列,就这样了 深拷贝和浅拷贝的实现方式以及区别Python中直接赋值python中的直接赋值相当于传递对象的引用而已，原对象改变，被赋值的对象也会改变。 Python中浅拷贝copy浅拷贝，没有拷贝子对象（这里应该指的是可变对象），只是将新对象给了一个新的首地址，里面的数据和地址都和原始数据相同，所以原始数据改变，子对象会改变。 Python中深拷贝python中的深拷贝，包含对原始对象的子对象的深拷贝，所以，对原拷贝对象的改变不会对深拷贝后对象没有任何影响。 总结1、赋值：简单地拷贝对象的引用，两个对象的id相同。2、浅拷贝：创建一个新的组合对象，这个新对象与原对象共享内存中的子对象。3、深拷贝：创建一个新的组合对象，同时递归地拷贝所有子对象，新的组合对象与原对象没有任何关联。虽然实际上会共享不可变的子对象，但不影响它们的相互独立性。 浅拷贝和深拷贝的不同仅仅是对组合对象来说，所谓的组合对象就是包含了其它对象的对象，如列表，类实例。而对于数字、字符串以及其它“原子”类型，没有拷贝一说，产生的都是原对象的引用。 __new__()与__init__()的区别new方法是类创建实例的方法， 创建对象时调用，返回当前对象的一个实例init()方法是类实例创建之后调用，用于对当前对象的一些初始化，没有返回值。new()方法和init()方法所接收的参数是一样的。需要注意的几点：1、init()函数并不相当于C++或者C#中的构造函数，因为在执行init()函数的时候，实例已经构造出来了2、子类可以不重写init()方法，实例化子类时可以自动调用超类中已定义的init()方法。但是如果重写了init()，实例化子类时将不会再 隐式的去调用超类中已定义的init()代码。3、如果重写了init()，为了能使用或扩展超类中的行为，最好显式的调用超类的init()方法 [^_^]: 参考阅读 Python基础面试中常常问道的问题]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[海量数据处理]]></title>
    <url>%2F2018%2F08%2F21%2F%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[[^_^]: &gt; 海量数据处理处理方法Hashing适用范围：快速查找，删除的基本数据结构，通常需要总数据量可以放入内存基本原理及要点： hash函数选择，针对字符串，整数，排列，具体相应的hash方法。碰撞处理，一种是open hashing，也称为拉链法；另一种就是closed hashing，也称开地址法，opened addressing。数组的特点是：寻址容易，插入和删除困难；而链表的特点是：寻址困难，插入和删除容易。那么我们能不能综合两者的特性，做出一种寻址容易，插入删除也容易的数据结构？答案是肯定的，这就是我们要提起的哈希表，哈希表有多种不同的实现方法，最常用的一种方法——拉链法，我们可以理解为“链表的数组” ####bit-map适用范围：可进行数据的快速查找，判重，删除，一般来说数据范围是int的10倍以下基本原理及要点：使用bit数组来表示某些元素是否存在，比如8位电话号码扩展：bloom filter可以看做是对bit-map的扩展 双层桶划分事实上，与其说双层桶划分是一种数据结构，不如说它是一种算法设计思想。面对一堆大量的数据我们无法处理的时候，我们可以将其分成一个个小的单元，然后根据一定的策略来处理这些小单元，从而达到目的。适用范围：第k大，中位数，不重复或重复的数字基本原理及要点：因为元素范围很大，不能利用直接寻址表，所以通过多次划分，逐步确定范围，然后最后在一个可以接受的范围内进行, 分治才是其根本。问题实例： 堆适用范围：海量数据前n大，并且n比较小，堆可以放入内存 （适合大数据量，求前n小，n的大小比较小的情况，这样可以扫描一遍即可得到所有的前n元素，效率很高）扩展：双堆，一个最大堆与一个最小堆结合，可以用来维护中位数。问题实例： 100w个数中找最大的前100个数。 倒排索引(Inverted index)适用范围：搜索引擎，关键字查询基本原理及要点：为何叫倒排索引？一种索引方法，被用来存储在全文搜索下某个单词在一个文档或者一组文档中的存储位置的映射。以英文为例，下面是要被索引的文本：T0 = “it is what it is”T1 = “what is it”T2 = “it is a banana”我们就能得到下面的反向文件索引：“a”: {2}“banana”: {2}“is”: {0, 1, 2}“it”: {0, 1, 2}“what”: {0, 1}检索的条件”what”, “is” 和 “it” 将对应集合的交集。正向索引开发出来用来存储每个文档的单词的列表。正向索引的查询往往满足每个文档有序频繁的全文查询和每个单词在校验文档中的验证这样的查询。在正向索引中，文档占据了中心的位置，每个文档指向了一个它所包含的索引项的序列。也就是说文档指向了它包含的那些单词，而反向索引则是单词指向了包含它的文档，很容易看到这个反向的关系。 问题实例Hashing海量日志数据，提取出某日访问百度次数最多的那个IP。IP是32位的，最多有个2^32个IP。同样可以采用映射的方法，比如模1000，把整个大文件映射为1000个小文件，再找出每个小文中出现频率最大的IP（可以采用hash_map进行频率统计，然后再找出频率最大的几个）及相应的频率。然后再在这1000个最大的IP中，找出那个频率最大的IP，即为所求。 搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。），请你统计最热门的10个查询串，要求使用的内存不能超过1G。 第一步借用hash统计进行预处理： 先对这批海量数据预处理(维护一个Key为Query字串，Value为该Query出现次数，即Hashmap(Query，Value)，每次读取一个Query，如果该字串不在Table中，那么加入该字串，并且将Value值设为1；如果该字串在Table中，那么将该字串的计数加一即可。最终我们在O(N)（N为1千万，因为要遍历整个数组一遍才能统计处每个query出现的次数）的时间复杂度内用Hash表完成了统计； 第二步借用堆排序找出最热门的10个查询串：时间复杂度为N’*logK。维护一个K(该题目中是10)大小的小根堆，然后遍历3百万个Query，分别和根元素进行对比（对比value的值），找出10个value值最大的query 最终的时间复杂度是：O（N） + N’*O（logK），（N为1000万，N’为300万）或者：采用trie树，关键字域存该查询串出现的次数，没有出现为0。最后用10个元素的最小推来对出现频率进行排序。 有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。第一步分而治之/hash映射到顺序读文件中，对于每个词x，取hash(x)%5000，然后按照该值存到5000个小文件（记为x0,x1,…x4999）中。这样每个文件大概是200k左右。如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M。 第二步hash统计对每个小文件，统计每个文件中出现的词以及相应的频率（可以采用trie树/hash_map等），并取出出现频率最大的100个词（可以用含100个结点的最小堆），并把100个词及相应的频率存入文件，这样又得到了5000个文件。 第三步堆/归并排序就是把这5000个文件进行归并（也可以采用堆排序）的过程了。（如果内存允许可以将这5000个文件中的所有元素合并起来，利用堆获得top 100） 给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？可以估计每个文件安的大小为5G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件（记为a0,a1,…,a999）中。这样每个小文件的大约为300M。遍历文件b，采取和a相同的方式将url分别存储到1000小文件（记为b0,b1,…,b999）。这样处理后，所有可能相同的url都在对应的小文件（a0vsb0,a1vsb1,…,a999vsb999）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。 位图存储（bitmap） 已知某个文件内包含一些电话号码，每个号码为8位数字，统计不同号码的个数（共有都少个不同的号码）。8位最多99 999 999（0-99 999 999共1亿个数），每个数字对应一个Bit位，所以只需要99MBit==1.2MBytes，这样，就用了小小的1.2M左右的内存表示了所有的8位数的电话） 2.5亿个整数（int）中找出不重复的整数的个数，内存足够大。将bit-map扩展一下，用2bit表示一个数即可，0表示未出现，1表示出现一次，2表示出现2次及以上。或者我们不用2bit来进行表示，我们用两个bit-map即可模拟实现这个2bit-map。 （每个整数用两位，存储所有的整数需要2^32*2=1GB的内存） 2.5亿个整数中找出不重复的整数的个数，内存空间不足以容纳这2.5亿个整数。整数个数为2^32，我们可以将这2^32个数，划分为2^8个区域(比如用单个文件代表一个区域)，然后将数据分离到不同的区域，然后不同的区域在利用bitmap（占用4MB，内存可以存下）就可以直接解决了。也就是说只要有足够的磁盘空间，就可以很方便的解决。 5亿个int找它们的中位数 (指将统计总体当中的各个变量值按大小顺序排列起来，形成一个数列，处于变量数列中间位置的变量值就称为中位数)首先我们将int划分为2^16个区域（肯定是按大小的），然后读取数据统计落到各个区域里的数的个数，之后我们根据统计结果就可以判断中位数落到那个区域，同时知道这个区域中的第几大数刚好是中位数。 然后第二次扫描我们只统计落在这个区域中的那些数就可以了。 腾讯面试题：给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？方案1：申请512M的内存（2^32/8=512MB），一个bit位代表一个unsigned int值。读入40亿个数，设置相应的bit位，读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在。 方案2：因为2^32为40亿多，所以给定一个数可能在，也可能不在其中；这里我们把40亿个数中的每一个用32位的二进制来表示假设这40亿个数开始放在一个文件中。然后将这40亿个数分成两类: 1. 最高位为0 2. 最高位为1并将这两类分别写入到两个文件中，其中一个文件中数的个数&lt;=20亿，而另一个&gt;=20亿（这相当于折半了）；与要查找的数的最高位比较并接着进入相应的文件再查找再然后把这个文件为又分成两类: 1.次最高位为0 2.次最高位为1并将这两类分别写入到两个文件中，其中一个文件中数的个数&lt;=10亿，而另一个&gt;=10亿（这相当于折半了）； 与要查找的数的次最高位比较并接着进入相应的文件再查找。 ……. 以此类推，就可以找到了,而且时间复杂度为O(logn)。 [^_^]: &gt; 参考阅读 - []()]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程和和线程]]></title>
    <url>%2F2018%2F08%2F20%2F%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%92%8C%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[[^_^]: &gt; 进程和和线程定义进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源. 关系一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。 区别进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。1) 简而言之,一个程序至少有一个进程,一个进程至少有一个线程.2) 线程的划分尺度小于进程，使得多线程程序的并发性高。3) 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。4) 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。5) 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。 优缺点线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。 [^_^]: &gt; 参考阅读 - []()]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>进程</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kafka]]></title>
    <url>%2F2018%2F08%2F20%2Fkafka%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[hexo]]></title>
    <url>%2F2018%2F08%2F19%2Fhexo%E6%96%87%E6%A1%A3%E7%BC%96%E5%86%99%2F</url>
    <content type="text"><![CDATA[Hexo基本操作init$ hexo init [folder]新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。 new$ hexo new [layout] 新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。(自测引号也是可以的) generate$ hexo generate生成静态文件。选项 描述-d, –deploy 文件生成后立即部署网站-w, –watch 监视文件变动该命令可以简写为：$ hexo g publish$ hexo publish [layout] 发表草稿。 server$ hexo server启动服务器。默认情况下，访问网址为： http://localhost:4000/。选项 描述：-p, –port 重设端口-s, –static 只使用静态文件-l, –log 启动日记记录，使用覆盖记录格式 deploy$ hexo deploy部署网站。参数 描述-g, –generate 部署之前预先生成静态文件该命令可以简写为：$ hexo d render$ hexo render [file2] …渲染文件。参数 描述：-o, –output 设置输出路径 migrate$ hexo migrate 从其他博客系统 迁移内容。 clean$ hexo clean清除缓存文件 (db.json) 和已生成的静态文件 (public)。 在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。 list$ hexo list 列出网站资料。 version$ hexo version显示 Hexo 版本。 markdown语法GFM]]></content>
  </entry>
  <entry>
    <title><![CDATA[快速排序]]></title>
    <url>%2F2018%2F08%2F19%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[快速排序123456789101112131415161718192021222324252627int sort(vector&lt;int&gt; arr) &#123; quickSort(arr, 0, arr.size()-1);&#125;void quickSort(vector&lt;int&gt; &amp;arr, int l, int r) &#123; if (l &lt; r) &#123; int pivot = partition(arr, l, r); quickSort(arr, l, pivot-1); quickSort(arr, pivot+1, r); &#125;&#125;int partition(vector&lt;int&gt; &amp;arr, int l, int r) &#123; int pivot; pivot = arr[l]; while (l &lt; r) &#123; while (l&lt;r &amp;&amp; arr[r] &gt;= pivot) &#123; --r; &#125; swap(arr[l], arr[r]); while(l&lt;r &amp;&amp; arr[l]&lt;=pivot) &#123; ++l; &#125; swap(arr[l], swap(r)); &#125; return l;&#125; 参考链接：https://www.jianshu.com/p/bc62a66be82chttps://segmentfault.com/a/1190000002651247]]></content>
  </entry>
  <entry>
    <title><![CDATA[三次握手和四次挥手]]></title>
    <url>%2F2018%2F08%2F18%2F%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%2F</url>
    <content type="text"><![CDATA[三次握手：1、客户端向服务器端发送报文SYN=1，ACK=0;客户端进入SYN-SEND状态。2、服务端收到SYN=1，ACK=0的请求报文，向客户端返回确认报文SYN=1,ACK=1,服务端进入SYN-REVD状态。3、客户端接收确认报文，需再向服务端发送一个确认收到的报文ACK=1；客户端进入ESTABLISHED状态。 四次挥手：1、客户端发起、请求断开链接。发送报文FIN=1，当FIN=1的时候，表明此报文的发送方已经完成了数据的发送，没有新的数据要传送，并要求释放链接。客户端进入FIN-WAIT-1状态。2、 服务器收到客户端的请求断开链接的报文之后，返回确认信息。ACK=1，服务器进入CLOSE-WAIT状态。此时客户端不能给服务器发送信息报文，只能接收。3、 当服务器也没有了可以传的信息之后，给客户端发送请求结束的报文。FIN=1，ACK=1，服务器进入LAST-ACK状态。4、 客户端接收到FIN=1的报文之后，返回确认报文，ACK=1，发送完毕之后，客户端进入等待状态，等待两个时间周期。链接关闭。注意：为什么要等两个时间周期：超时重传机制客户端最后一个确认收到的ACK=1的报文如果在传输的过程中丢失，服务端没有收到确认报文，就会超时重传，重新发送FIN=1的报文，如果不等两个时间周期，重新发的FIN=1的报文客户端不会收到。 1、为什么连接的时候是三次握手，关闭的时候却是四次握手？答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。 2、为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>三次握手</tag>
        <tag>四次挥手</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux中添加-删除用户并设置权限Ⅱ]]></title>
    <url>%2F2018%2F08%2F17%2FLinux%E4%B8%AD%E6%B7%BB%E5%8A%A0-%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7%E5%B9%B6%E8%AE%BE%E7%BD%AE%E6%9D%83%E9%99%90%E2%85%A1%2F</url>
    <content type="text"><![CDATA[在“Linux中添加/删除用户并设置权限”一文中，我们讲了如何添加及删除用户，可是后来，我们仍遇到了不少问题： 1.进入系统后命令行只有一个’\$’ 这样的美元符号,而且环境变量文件已经都复制到用户主目录下，怎样才能恢复成如xxx@主机名:~$ 这样的格式呢？1vim /etc/passwd 看到自己的用户名，如：1test:x:():()::/home/test: 在后面加上/bin/bash，就行了。即：1test:x:():()::/home/test:/bin/bash 如果出现”/etc/passwd” E212: Can’t open file for writing,说明权限有问题，退出后，执行chattr -i /etc/passwd，即可更改。 2.无法使用root权限123sudo -i[sudo] password for test: test is not in the sudoers file. This incident will be reported. （1）添加sudo文件的写权限,命令是:1chmod u+w /etc/sudoers （2）编辑sudoers文件12345vim /etc/sudoers``找到这一行``root ALL=(ALL:ALL) ALL 在它下面添加：1xxx ALL=(ALL:ALL) ALL #这里的xxx是你的用户名 ps:这里说下你可以sudoers添加下面四行中任意一条即可。1234youuser ALL=(ALL) ALL%youuser ALL=(ALL) ALLyouuser ALL=(ALL) NOPASSWD: ALL%youuser ALL=(ALL) NOPASSWD: ALL 第一行:允许用户youuser执行sudo命令(需要输入密码).第二行:允许用户组youuser里面的用户执行sudo命令(需要输入密码).第三行:允许用户youuser执行sudo命令,并且在执行的时候不输入密码.第四行:允许用户组youuser里面的用户执行sudo命令,并且在执行的时候不输入密码。 （3）撤销sudoers文件写权限,命令:1chmod u-w /etc/sudoers 这样普通用户就可以使用sudo了.]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux中添加-删除用户并设置权限]]></title>
    <url>%2F2018%2F08%2F17%2FLinux%E4%B8%AD%E6%B7%BB%E5%8A%A0-%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7%E5%B9%B6%E8%AE%BE%E7%BD%AE%E6%9D%83%E9%99%90%2F</url>
    <content type="text"><![CDATA[创建建用户(在root用户下)12useradd -d /home/test -m test #增加用户test，并制定test用户的主目录为/home/testpasswd test #为test用户设置密码 更改用户相应的权限设置：123usermod -s /sbin/nologin test #限定用户test不能telnet，只能ftpusermod -s /bin/bash test #用户test恢复正常usermod -d /home/test test #更改用户test的主目录为/test 限制用户只能访问/home/test，不能访问其他路径修改/etc/vsftpd/vsftpd.conf如下：123chroot_list_enable=YES #限制访问自身目录# (default follows)chroot_list_file=/etc/vsftpd/vsftpd.chroot_list 编辑 vsftpd.chroot_list文件，将受限制的用户添加进去，每个用户名一行 改完配置文件，不要忘记重启vsftpd服务器1reboot 5.如果需要允许用户修改密码，但是又没有telnet登录系统的权限：1usermod -s /usr/bin/passwd test #用户telnet后将直接进入改密界面 6.如果要删除用户，用下面代码：1userdel -r newuser 因为需要彻底删除用户，所以加上-r的选项，在删除用户的同时一起把这个用户的宿主目录和邮件目录删除。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Linux命令提示符显示当前完整路径]]></title>
    <url>%2F2018%2F08%2F16%2FLinux%E5%91%BD%E4%BB%A4%E6%8F%90%E7%A4%BA%E7%AC%A6%E6%98%BE%E7%A4%BA%E5%BD%93%E5%89%8D%E5%AE%8C%E6%95%B4%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[问题：linux下，命令行显示路径仅最后一个文件名，非常不方便，想显示完整路径。环境背景：linux，无root权限，可sudo(为了服务器安全，一般只给管理员root账号和密码，普通账号仅sudo权限)方法：修改环境变量PS1，vi编辑/etc/profile文件在最后加上一行语句。 命令行提示符完全显示完整的工作目录名称：export PS1=’[\u@\h $PWD]\$ ‘ 命令行提示符只列出最后一个目录：export PS1=’[\u@\h \W]$ ‘ 命令行提示符显示完整工作目录，当前用户目录会以 ~代替：export PS1=’[\u@\h \w]$ ‘修改完成后，执行: source /etc/profile 使配置生效即可。 命令释义：\u 显示当前用户账号\h 显示当前主机名\W 只显示当前路径最后一个目录\w 显示当前绝对路径（当前用户目录会以 ~代替）$PWD 显示当前全路径\$ 显示命令行’$’或者’#’符号]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F25%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
